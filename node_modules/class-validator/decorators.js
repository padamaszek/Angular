"use strict";
var MetadataStorage_1 = require("./metadata/MetadataStorage");
var ValidationTypes_1 = require("./ValidationTypes");
/**
 * Decorator used to register custom validators.
 */
function ValidatorConstraint() {
    return function (object) {
        MetadataStorage_1.defaultMetadataStorage.addConstraintMetadata({
            object: object
        });
    };
}
exports.ValidatorConstraint = ValidatorConstraint;
/**
 * Performs validation based on the given custom validation class.
 */
function Validate(constraintClass, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.CUSTOM_VALIDATION,
            object: object,
            propertyName: propertyName,
            value1: constraintClass,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.Validate = Validate;
/**
 * Checks if the string contains the seed.
 */
function Contains(seed, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.CONTAINS,
            object: object,
            propertyName: propertyName,
            value1: seed,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.Contains = Contains;
/**
 * Checks if the string matches the comparison.
 */
function Equals(comparison, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.EQUALS,
            object: object,
            propertyName: propertyName,
            value1: comparison,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.Equals = Equals;
/**
 * Checks if the string is a date that's after the specified date.
 */
function IsAfter(date, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_AFTER,
            object: object,
            propertyName: propertyName,
            value1: date,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsAfter = IsAfter;
/**
 * Checks if the string contains only letters (a-zA-Z).
 */
function IsAlpha(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_ALPHA,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsAlpha = IsAlpha;
/**
 * Checks if the string contains only letters and numbers.
 */
function IsAlphanumeric(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_ALPHANUMERIC,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsAlphanumeric = IsAlphanumeric;
/**
 * Checks if the string contains ASCII chars only.
 */
function IsAscii(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_ASCII,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsAscii = IsAscii;
/**
 * Checks if a string is base64 encoded.
 */
function IsBase64(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_BASE64,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsBase64 = IsBase64;
/**
 * Checks if the string is a date that's before the specified date.
 */
function IsBefore(date, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_BEFORE,
            object: object,
            propertyName: propertyName,
            value1: date,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsBefore = IsBefore;
/**
 * Checks if a value is a boolean.
 */
function IsBoolean(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_BOOLEAN,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsBoolean = IsBoolean;
/**
 * Checks if a string is a boolean.
 */
function IsBooleanString(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_BOOLEAN_STRING,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsBooleanString = IsBooleanString;
/**
 * Checks if the string's length (in bytes) falls in a range.
 */
function IsByteLength(min, max, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_BYTE_LENGTH,
            object: object,
            propertyName: propertyName,
            value1: min,
            value2: max,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsByteLength = IsByteLength;
/**
 * Checks if the string is a credit card.
 */
function IsCreditCard(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_CREDIT_CARD,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsCreditCard = IsCreditCard;
/**
 * Checks if the string is a valid currency amount.
 */
function IsCurrency(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_CURRENCY,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsCurrency = IsCurrency;
/**
 * Checks if the string is a date.
 */
function IsDate(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_DATE,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsDate = IsDate;
/**
 * Checks if the string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.
 */
function IsDecimal(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_DECIMAL,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsDecimal = IsDecimal;
/**
 * Checks if the string is a number that's divisible by another.
 */
function IsDivisibleBy(num, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_DIVISIBLE_BY,
            object: object,
            propertyName: propertyName,
            value1: num,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsDivisibleBy = IsDivisibleBy;
/**
 * Checks if the string is an email.
 */
function IsEmail(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_EMAIL,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsEmail = IsEmail;
/**
 * Checks if the string is a fully qualified domain name (e.g. domain.com).
 */
function IsFQDN(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_FQDN,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsFQDN = IsFQDN;
/**
 * Checks if the string is a float.
 */
function IsFloat(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_FLOAT,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsFloat = IsFloat;
/**
 * Checks if the string is a positive float.
 */
function IsPositiveFloat(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_POSITIVE_FLOAT,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsPositiveFloat = IsPositiveFloat;
/**
 * Checks if the string is a negative float.
 */
function IsNegativeFloat(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_NEGATIVE_FLOAT,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsNegativeFloat = IsNegativeFloat;
/**
 * Checks if the string contains any full-width chars.
 */
function IsFullWidth(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_FULL_WIDTH,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsFullWidth = IsFullWidth;
/**
 * Checks if the string contains any half-width chars.
 */
function IsHalfWidth(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_HALF_WIDTH,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsHalfWidth = IsHalfWidth;
/**
 * Checks if the string contains a mixture of full and half-width chars.
 */
function IsVariableWidth(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_VARIABLE_WIDTH,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsVariableWidth = IsVariableWidth;
/**
 * Checks if the string is a hexadecimal color.
 */
function IsHexColor(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_HEX_COLOR,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsHexColor = IsHexColor;
/**
 * Checks if the string is a hexadecimal number.
 */
function IsHexadecimal(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_HEXADECIMAL,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsHexadecimal = IsHexadecimal;
/**
 * Checks if the string is an IP (version 4 or 6).
 */
function IsIP(version, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_IP,
            object: object,
            propertyName: propertyName,
            value1: version,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsIP = IsIP;
/**
 * Checks if the string is an ISBN (version 10 or 13).
 */
function IsISBN(version, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_ISBN,
            object: object,
            propertyName: propertyName,
            value1: version,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsISBN = IsISBN;
/**
 * Checks if the string is an ISIN (stock/security identifier).
 */
function IsISIN(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_ISIN,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsISIN = IsISIN;
/**
 * Checks if the string is a valid ISO 8601 date.
 */
function IsISO8601(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_ISO8601,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsISO8601 = IsISO8601;
/**
 * Checks if the string is in a array of allowed values.
 */
function IsIn(values, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_IN,
            object: object,
            propertyName: propertyName,
            value1: values,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsIn = IsIn;
/**
 * Checks if the string is an integer.
 */
function IsInt(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_INT,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsInt = IsInt;
/**
 * Checks if the string is a positive integer.
 */
function IsPositiveInt(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_POSITIVE_INT,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsPositiveInt = IsPositiveInt;
/**
 * Checks if the string is a negative integer.
 */
function IsNegativeInt(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_NEGATIVE_INT,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsNegativeInt = IsNegativeInt;
/**
 * Checks if the string is valid JSON (note: uses JSON.parse).
 */
function IsJSON(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_JSON,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsJSON = IsJSON;
/**
 * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.
 */
function IsLength(min, max, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_LENGTH,
            object: object,
            propertyName: propertyName,
            value1: min,
            value2: max,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsLength = IsLength;
/**
 * Checks if the string is lowercase.
 */
function IsLowercase(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_LOWERCASE,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsLowercase = IsLowercase;
/**
 * Checks if the string is a mobile phone number (locale is one of ['zh-CN', 'zh-TW', 'en-ZA', 'en-AU', 'en-HK',
 * 'pt-PT', 'fr-FR', 'el-GR', 'en-GB', 'en-US', 'en-ZM', 'ru-RU', 'nb-NO', 'nn-NO', 'vi-VN', 'en-NZ']).
 */
function IsMobilePhone(locale, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_MOBILE_PHONE,
            object: object,
            propertyName: propertyName,
            value1: locale,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsMobilePhone = IsMobilePhone;
/**
 * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.
 */
function IsMongoId(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_MONGO_ID,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsMongoId = IsMongoId;
/**
 * Checks if the string contains one or more multibyte chars.
 */
function IsMultibyte(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_MULTIBYTE,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsMultibyte = IsMultibyte;
/**
 * Checks if the string is null.
 */
function IsNull(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_NULL,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsNull = IsNull;
/**
 * Checks if the string is numeric.
 */
function IsNumeric(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_NUMERIC,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsNumeric = IsNumeric;
/**
 * Checks if the string contains any surrogate pairs chars.
 */
function IsSurrogatePair(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_SURROGATE_PAIR,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsSurrogatePair = IsSurrogatePair;
/**
 * Checks if the string is a fully qualified domain name (e.g. domain.com).
 */
function IsUrl(options, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_URL,
            object: object,
            propertyName: propertyName,
            value1: options,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsUrl = IsUrl;
/**
 * Checks if the string is a UUID (version 3, 4 or 5).
 */
function IsUUID(version, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_UUID,
            object: object,
            propertyName: propertyName,
            value1: version,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsUUID = IsUUID;
/**
 * Checks if the string is uppercase.
 */
function IsUppercase(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.IS_UPPERCASE,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.IsUppercase = IsUppercase;
function Matches(pattern, modifiersOrAnnotationOptions, annotationOptions) {
    var modifiers;
    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !annotationOptions) {
        annotationOptions = modifiersOrAnnotationOptions;
    }
    else {
        modifiers = modifiersOrAnnotationOptions;
    }
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.MATCHES,
            object: object,
            propertyName: propertyName,
            value1: pattern,
            value2: modifiers,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.Matches = Matches;
/**
 * Checks if the string's length is not less then given number. Note: this function takes into account surrogate pairs.
 */
function MinLength(min, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.MIN_LENGTH,
            object: object,
            propertyName: propertyName,
            value1: min,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.MinLength = MinLength;
/**
 * Checks if the string's length is not more then given number. Note: this function takes into account surrogate pairs.
 */
function MaxLength(max, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.MAX_LENGTH,
            object: object,
            propertyName: propertyName,
            value1: max,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.MaxLength = MaxLength;
/**
 * Checks if the given number is not less then given number.
 */
function MinNumber(min, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.MIN_NUMBER,
            object: object,
            propertyName: propertyName,
            value1: min,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.MinNumber = MinNumber;
/**
 * Checks if the given number is not more then given number.
 */
function MaxNumber(max, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.MAX_NUMBER,
            object: object,
            propertyName: propertyName,
            value1: max,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.MaxNumber = MaxNumber;
/**
 * Checks if given value is not empty.
 */
function NotEmpty(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.NOT_EMPTY,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.NotEmpty = NotEmpty;
/**
 * Checks if given array is not empty.
 */
function NotEmptyArray(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.NOT_EMPTY_ARRAY,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.NotEmptyArray = NotEmptyArray;
/**
 * Checks if array's length is as minimal this number.
 */
function MinSize(min, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.MIN_SIZE,
            object: object,
            propertyName: propertyName,
            value1: min,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.MinSize = MinSize;
/**
 * Checks if array's length is as maximal this number.
 */
function MaxSize(max, annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.MAX_SIZE,
            object: object,
            propertyName: propertyName,
            value1: max,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.MaxSize = MaxSize;
/**
 * Indicates if nested object should be validated as well.
 */
function ValidateNested(annotationOptions) {
    return function (object, propertyName) {
        MetadataStorage_1.defaultMetadataStorage.addValidationMetadata({
            type: ValidationTypes_1.ValidationTypes.NESTED_VALIDATION,
            object: object,
            propertyName: propertyName,
            groups: annotationOptions && annotationOptions.groups ? annotationOptions.groups : undefined,
            message: annotationOptions && annotationOptions.message ? annotationOptions.message : undefined,
            always: annotationOptions && annotationOptions.always ? annotationOptions.always : undefined,
            each: annotationOptions && annotationOptions.each ? annotationOptions.each : undefined
        });
    };
}
exports.ValidateNested = ValidateNested;
//# sourceMappingURL=decorators.js.map