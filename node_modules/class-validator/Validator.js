"use strict";
var ValidationTypes_1 = require("./ValidationTypes");
var MetadataStorage_1 = require("./metadata/MetadataStorage");
var ValidationTypes_2 = require("./ValidationTypes");
var ValidationError_1 = require("./ValidationError");
var validatatorJs = require("validator");
/**
 * Validator performs validation of the given object based on its metadata.
 */
var Validator = (function () {
    function Validator() {
        this.metadataStorage = MetadataStorage_1.defaultMetadataStorage;
    }
    Object.defineProperty(Validator.prototype, "container", {
        // -------------------------------------------------------------------------
        // Accessors
        // -------------------------------------------------------------------------
        set: function (container) {
            this._container = container;
        },
        enumerable: true,
        configurable: true
    });
    // -------------------------------------------------------------------------
    // Annotation-based Validation Methods
    // -------------------------------------------------------------------------
    /**
     * Performs validation of the given object based on annotations used in given object class.
     */
    Validator.prototype.validate = function (object, validatorOptions) {
        var _this = this;
        var groups = validatorOptions ? validatorOptions.groups : undefined;
        var metadatas = this.metadataStorage.getValidationMetadatasForObject(object.constructor, groups);
        return metadatas.map(function (metadata) {
            var value = object[metadata.propertyName];
            if (!value && validatorOptions && validatorOptions.skipMissingProperties === true)
                return null;
            var duplicateMetadatas = metadatas.filter(function (m) { return m.propertyName === metadata.propertyName && m.type === metadata.type; });
            var errors = duplicateMetadatas.map(function (metadata) {
                var isValid = true;
                if (metadata.each) {
                    if (value instanceof Array)
                        isValid = value.every(function (v) { return _this.performValidation(v, metadata); });
                }
                else {
                    isValid = _this.performValidation(value, metadata);
                }
                if (isValid)
                    return null;
                return {
                    property: metadata.propertyName,
                    errorCode: metadata.type,
                    errorName: ValidationTypes_2.ValidationTypesUtils.getCodeName(metadata.type),
                    errorMessage: metadata.message,
                    value: value,
                    required: metadata.value1
                };
            });
            var nestedValidation = duplicateMetadatas.reduce(function (found, metadata) {
                return metadata.type === ValidationTypes_1.ValidationTypes.NESTED_VALIDATION ? metadata : found;
            }, undefined);
            if (nestedValidation) {
                if (value instanceof Array) {
                    value.map(function (v) {
                        var nestedErrors = _this.validate(v, validatorOptions);
                        if (nestedErrors && nestedErrors.length)
                            errors = errors.concat(nestedErrors);
                    });
                }
                else if (value instanceof Object) {
                    var nestedErrors = _this.validate(value, validatorOptions);
                    if (nestedErrors && nestedErrors.length)
                        errors = errors.concat(nestedErrors);
                }
                else {
                    throw new Error("Only objects and arrays are supported to nested validation");
                }
            }
            return errors.reduceRight(function (found, err) { return err !== null ? err : found; }, null);
        }).filter(function (error) { return error !== null; });
    };
    /**
     * Performs validation of the given object based on annotations used in given object class.
     * Performs in async-style, useful to use it in chained promises.
     */
    Validator.prototype.validateAsync = function (object, validatorOptions) {
        var _this = this;
        return new Promise(function (ok, fail) {
            var errors = _this.validate(object, validatorOptions);
            if (errors.length > 0) {
                fail(new ValidationError_1.ValidationError(errors));
            }
            else {
                ok(object);
            }
        });
    };
    /**
     * Performs validation of the given object based on annotations used in given object class.
     * If validation is not passed then throws ValidationError.
     */
    Validator.prototype.validateOrThrow = function (object, validatorOptions) {
        var errors = this.validate(object, validatorOptions);
        if (errors.length > 0)
            throw new ValidationError_1.ValidationError(errors);
    };
    /**
     * Checks if given object is valid (all annotations passes validation). Returns true if its valid, false otherwise.
     */
    Validator.prototype.isValid = function (object, validatorOptions) {
        return this.validate(object, validatorOptions).length === 0;
    };
    // -------------------------------------------------------------------------
    // Validation Methods
    // -------------------------------------------------------------------------
    /**
     * Checks if the string contains the seed.
     */
    Validator.prototype.contains = function (str, seed) {
        return validatatorJs.contains(str, seed);
    };
    /**
     * Checks if the string matches the comparison.
     */
    Validator.prototype.equals = function (str, comparison) {
        return validatatorJs.equals(str, comparison);
    };
    Validator.prototype.isAfter = function (date, afterDate) {
        var dateString = date instanceof Date ? date.toDateString() : date;
        var afterDateString = afterDate instanceof Date ? afterDate.toDateString() : afterDate;
        return validatatorJs.isAfter(dateString, afterDateString);
    };
    /**
     * Checks if the string contains only letters (a-zA-Z).
     */
    Validator.prototype.isAlpha = function (str) {
        return validatatorJs.isAlpha(str);
    };
    /**
     * Checks if the string contains only letters and numbers.
     */
    Validator.prototype.isAlphanumeric = function (str) {
        return validatatorJs.isAlphanumeric(str);
    };
    /**
     * Checks if the string contains ASCII chars only.
     */
    Validator.prototype.isAscii = function (str) {
        return validatatorJs.isAscii(str);
    };
    /**
     * Checks if a string is base64 encoded.
     */
    Validator.prototype.isBase64 = function (str) {
        return validatatorJs.isBase64(str);
    };
    Validator.prototype.isBefore = function (date, beforeDate) {
        var dateString = date instanceof Date ? date.toDateString() : date;
        var beforeDateString = beforeDate instanceof Date ? beforeDate.toDateString() : beforeDate;
        return validatatorJs.isBefore(dateString, beforeDateString);
    };
    /**
     * Checks if a string is a boolean.
     */
    Validator.prototype.isBooleanString = function (str) {
        return validatatorJs.isBoolean(str);
    };
    /**
     * Checks if a boolean is a real boolean;
     */
    Validator.prototype.isBoolean = function (value) {
        return value instanceof Boolean || typeof value === "boolean";
    };
    /**
     * Checks if the string's length (in bytes) falls in a range.
     */
    Validator.prototype.isByteLength = function (str, min, max) {
        return validatatorJs.isByteLength(str, min, max);
    };
    /**
     * Checks if the string is a credit card.
     */
    Validator.prototype.isCreditCard = function (str) {
        return validatatorJs.isCreditCard(str);
    };
    /**
     * Checks if the string is a valid currency amount.
     */
    Validator.prototype.isCurrency = function (str, options) {
        return validatatorJs.isCurrency(str, options);
    };
    /**
     * Checks if the string is a date.
     */
    Validator.prototype.isDate = function (str) {
        return validatatorJs.isDate(str);
    };
    /**
     * Checks if the string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.
     */
    Validator.prototype.isDecimal = function (str) {
        return validatatorJs.isDecimal(str);
    };
    /**
     * Checks if the string is a number that's divisible by another.
     */
    Validator.prototype.isDivisibleBy = function (str, num) {
        return validatatorJs.isDivisibleBy(str, num);
    };
    /**
     * Checks if the string is an email.
     */
    Validator.prototype.isEmail = function (str, options) {
        return validatatorJs.isEmail(str, options);
    };
    /**
     * Checks if the string is a fully qualified domain name (e.g. domain.com).
     */
    Validator.prototype.isFQDN = function (str, options) {
        return validatatorJs.isFQDN(str, options);
    };
    Validator.prototype.isFloat = function (val, options) {
        var numberString = String(val);
        return validatatorJs.isFloat(numberString, options);
    };
    Validator.prototype.isPositiveFloat = function (val, options) {
        var numberString = String(val);
        var num = typeof val === "number" ? val : parseFloat(val);
        return validatatorJs.isFloat(numberString, options) && num > 0;
    };
    Validator.prototype.isNegativeFloat = function (val, options) {
        var numberString = String(val);
        var num = typeof val === "number" ? val : parseFloat(val);
        return validatatorJs.isFloat(numberString, options) && num < 0;
    };
    /**
     * Checks if the string contains any full-width chars.
     */
    Validator.prototype.isFullWidth = function (str) {
        return validatatorJs.isFullWidth(str);
    };
    /**
     * Checks if the string contains any half-width chars.
     */
    Validator.prototype.isHalfWidth = function (str) {
        return validatatorJs.isHalfWidth(str);
    };
    /**
     * Checks if the string contains variable-width chars.
     */
    Validator.prototype.isVariableWidth = function (str) {
        return validatatorJs.isVariableWidth(str);
    };
    /**
     * Checks if the string is a hexadecimal color.
     */
    Validator.prototype.isHexColor = function (str) {
        return validatatorJs.isHexColor(str);
    };
    /**
     * Checks if the string is a hexadecimal number.
     */
    Validator.prototype.isHexadecimal = function (str) {
        return validatatorJs.isHexadecimal(str);
    };
    /**
     * Checks if the string is an IP (version 4 or 6).
     */
    Validator.prototype.isIP = function (str, version) {
        return validatatorJs.isIP(str, version);
    };
    /**
     * Checks if the string is an ISBN (version 10 or 13).
     */
    Validator.prototype.isISBN = function (str, version) {
        return validatatorJs.isISBN(str, version);
    };
    /**
     * Checks if the string is an ISIN (stock/security identifier).
     */
    Validator.prototype.isISIN = function (str) {
        return validatatorJs.isISIN(str);
    };
    /**
     * Checks if the string is a valid ISO 8601 date.
     */
    Validator.prototype.isISO8601 = function (str) {
        return validatatorJs.isISO8601(str);
    };
    /**
     * Checks if the string is in a array of allowed values.
     */
    Validator.prototype.isIn = function (str, values) {
        return validatatorJs.isIn(str, values);
    };
    Validator.prototype.isInt = function (val, options) {
        var numberString = String(val);
        return validatatorJs.isInt(numberString, options);
    };
    Validator.prototype.isPositiveInt = function (val, options) {
        var numberString = String(val);
        var num = typeof val === "number" ? val : parseInt(val);
        return validatatorJs.isInt(numberString, options) && num > 0;
    };
    Validator.prototype.isNegativeInt = function (val, options) {
        var numberString = String(val);
        var num = typeof val === "number" ? val : parseInt(val);
        return validatatorJs.isInt(numberString, options) && num < 0;
    };
    /**
     * Checks if the string is valid JSON (note: uses JSON.parse).
     */
    Validator.prototype.isJSON = function (str) {
        return validatatorJs.isJSON(str);
    };
    /**
     * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.
     */
    Validator.prototype.isLength = function (str, min, max) {
        return typeof str === "string" && validatatorJs.isLength(str, min, max);
    };
    /**
     * Checks if the string is lowercase.
     */
    Validator.prototype.isLowercase = function (str) {
        return validatatorJs.isLowercase(str);
    };
    /**
     * Checks if the string is a mobile phone number (locale is one of ['zh-CN', 'zh-TW', 'en-ZA', 'en-AU', 'en-HK',
     * 'pt-PT', 'fr-FR', 'el-GR', 'en-GB', 'en-US', 'en-ZM', 'ru-RU', 'nb-NO', 'nn-NO', 'vi-VN', 'en-NZ']).
     */
    Validator.prototype.isMobilePhone = function (str, locale) {
        return validatatorJs.isMobilePhone(str, locale);
    };
    /**
     * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.
     */
    Validator.prototype.isMongoId = function (str) {
        return validatatorJs.isMongoId(str);
    };
    /**
     * Checks if the string contains one or more multibyte chars.
     */
    Validator.prototype.isMultibyte = function (str) {
        return validatatorJs.isMultibyte(str);
    };
    /**
     * Checks if value is null.
     * @deprecated
     */
    Validator.prototype.isNull = function (value) {
        return value === null;
    };
    /**
     * Checks if the string is numeric.
     */
    Validator.prototype.isNumeric = function (str) {
        return validatatorJs.isNumeric(str);
    };
    /**
     * Checks if the string contains any surrogate pairs chars.
     */
    Validator.prototype.isSurrogatePair = function (str) {
        return validatatorJs.isSurrogatePair(str);
    };
    /**
     * Checks if the string contains any surrogate pairs chars.
     */
    Validator.prototype.isURL = function (str, options) {
        return validatatorJs.isURL(str, options);
    };
    /**
     * Checks if the string is a UUID (version 3, 4 or 5).
     */
    Validator.prototype.isUUID = function (str, version) {
        return validatatorJs.isUUID(str, version);
    };
    /**
     * Checks if the string is uppercase.
     */
    Validator.prototype.isUppercase = function (str) {
        return validatatorJs.isUppercase(str);
    };
    /**
     * Checks if string matches the pattern. Either matches('foo', /foo/i) or matches('foo', 'foo', 'i').
     */
    Validator.prototype.matches = function (str, pattern, modifiers) {
        return validatatorJs.matches(str, pattern, modifiers);
    };
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    Validator.prototype.performValidation = function (value, metadata) {
        var _this = this;
        switch (metadata.type) {
            case ValidationTypes_1.ValidationTypes.CONTAINS:
                return this.contains(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.EQUALS:
                return this.equals(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_AFTER:
                return this.isAfter(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_ALPHA:
                return this.isAlpha(value);
            case ValidationTypes_1.ValidationTypes.IS_ALPHANUMERIC:
                return this.isAlphanumeric(value);
            case ValidationTypes_1.ValidationTypes.IS_ASCII:
                return this.isAscii(value);
            case ValidationTypes_1.ValidationTypes.IS_BASE64:
                return this.isBase64(value);
            case ValidationTypes_1.ValidationTypes.IS_BEFORE:
                return this.isBefore(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_BOOLEAN_STRING:
                return this.isBooleanString(value);
            case ValidationTypes_1.ValidationTypes.IS_BOOLEAN:
                return this.isBoolean(value);
            case ValidationTypes_1.ValidationTypes.IS_BYTE_LENGTH:
                return this.isByteLength(value, metadata.value1, metadata.value2);
            case ValidationTypes_1.ValidationTypes.IS_CREDIT_CARD:
                return this.isCreditCard(value);
            case ValidationTypes_1.ValidationTypes.IS_CURRENCY:
                return this.isCurrency(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_DATE:
                return this.isDate(value);
            case ValidationTypes_1.ValidationTypes.IS_DECIMAL:
                return this.isDecimal(value);
            case ValidationTypes_1.ValidationTypes.IS_DIVISIBLE_BY:
                return this.isDivisibleBy(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_EMAIL:
                return this.isEmail(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_FQDN:
                return this.isFQDN(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_FLOAT:
                return this.isFloat(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_POSITIVE_FLOAT:
                return this.isPositiveFloat(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_NEGATIVE_FLOAT:
                return this.isNegativeFloat(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_FULL_WIDTH:
                return this.isFullWidth(value);
            case ValidationTypes_1.ValidationTypes.IS_HALF_WIDTH:
                return this.isHalfWidth(value);
            case ValidationTypes_1.ValidationTypes.IS_VARIABLE_WIDTH:
                return this.isVariableWidth(value);
            case ValidationTypes_1.ValidationTypes.IS_HEX_COLOR:
                return this.isHexColor(value);
            case ValidationTypes_1.ValidationTypes.IS_HEXADECIMAL:
                return this.isHexadecimal(value);
            case ValidationTypes_1.ValidationTypes.IS_IP:
                return this.isIP(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_ISBN:
                return this.isISBN(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_ISIN:
                return this.isISIN(value);
            case ValidationTypes_1.ValidationTypes.IS_ISO8601:
                return this.isISO8601(value);
            case ValidationTypes_1.ValidationTypes.IS_IN:
                return this.isIn(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_INT:
                return this.isInt(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_POSITIVE_INT:
                return this.isPositiveInt(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_NEGATIVE_INT:
                return this.isNegativeInt(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_JSON:
                return this.isJSON(value);
            case ValidationTypes_1.ValidationTypes.IS_LENGTH:
                return this.isLength(value, metadata.value1, metadata.value2);
            case ValidationTypes_1.ValidationTypes.IS_LOWERCASE:
                return this.isLowercase(value);
            case ValidationTypes_1.ValidationTypes.IS_MOBILE_PHONE:
                return this.isMobilePhone(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_MONGO_ID:
                return this.isMongoId(value);
            case ValidationTypes_1.ValidationTypes.IS_MULTIBYTE:
                return this.isMultibyte(value);
            case ValidationTypes_1.ValidationTypes.IS_NULL:
                return this.isNull(value);
            case ValidationTypes_1.ValidationTypes.IS_NUMERIC:
                return this.isNumeric(value);
            case ValidationTypes_1.ValidationTypes.IS_SURROGATE_PAIR:
                return this.isSurrogatePair(value);
            case ValidationTypes_1.ValidationTypes.IS_URL:
                return this.isURL(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_UUID:
                return this.isUUID(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.IS_UPPERCASE:
                return this.isUppercase(value);
            case ValidationTypes_1.ValidationTypes.MATCHES:
                return this.matches(value, metadata.value1, metadata.value2);
            // custom validation types
            case ValidationTypes_1.ValidationTypes.MIN_LENGTH:
                return this.isLength(value, metadata.value1);
            case ValidationTypes_1.ValidationTypes.MAX_LENGTH:
                return this.isLength(value, 0, metadata.value1);
            case ValidationTypes_1.ValidationTypes.MIN_NUMBER:
                return this.isInt(value, { min: metadata.value1 });
            case ValidationTypes_1.ValidationTypes.MAX_NUMBER:
                return this.isInt(value, { max: metadata.value1 });
            case ValidationTypes_1.ValidationTypes.NOT_EMPTY:
                return !!value;
            case ValidationTypes_1.ValidationTypes.NOT_EMPTY_ARRAY:
                return value instanceof Array && value.length > 0;
            case ValidationTypes_1.ValidationTypes.MIN_SIZE:
                if (value instanceof Array)
                    return value.length >= metadata.value1;
                break;
            case ValidationTypes_1.ValidationTypes.MAX_SIZE:
                if (value instanceof Array)
                    return value.length <= metadata.value1;
                break;
            case ValidationTypes_1.ValidationTypes.CUSTOM_VALIDATION:
                return this.metadataStorage
                    .getValidatorConstraintsForObject(metadata.value1)
                    .map(function (validatorMetadata) {
                    if (!validatorMetadata.instance)
                        validatorMetadata.instance = _this.createInstance(validatorMetadata.object);
                    return validatorMetadata.instance;
                }).every(function (validator) { return validator.validate(value); });
        }
        return true;
    };
    Validator.prototype.createInstance = function (object) {
        return this._container ? this._container.get(object) : new object();
    };
    return Validator;
}());
exports.Validator = Validator;
//# sourceMappingURL=Validator.js.map